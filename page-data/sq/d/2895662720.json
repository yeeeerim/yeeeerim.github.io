{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"lime"},"html":"<h2>1. 프로젝트 개요</h2>\n<p>LIME은 취미 관련 상품 구매 결정을 돕기 위해 개발된 서비스입니다.</p>\n<p>취미 상품 구매는 일반 상품과 달리 구매자의 취미 경험과 전문성이 필요하며, 개인의 기호에 맞는 상품 조합을 고려해야 하는 경우도 있습니다. 이러한 요구를 충족시키기 위해, 다양한 전문성을 가진 사람들이 취미 상품에 대해 자유롭게 의견을 묻고 피드백을 받을 수 있는 플랫폼을 제공하고자 기획하게 되었습니다!</p>\n<h2>2. 기능 명세</h2>\n<ul>\n<li><strong>홈</strong> : 다양한 취미 상품과 투표에 대한 최신 정보를 제공하는 메인 페이지</li>\n<li><strong>소셜로그인</strong> : 사용자 인증을 통해 개인화된 서비스를 제공하기 위한 기능</li>\n<li><strong>회원가입</strong> : 새로운 사용자가 가입하여 서비스를 이용할 수 있도록 지원</li>\n<li><strong>아이템 생성/추가/조회/검색</strong>: 사용자가 새로운 아이템을 생성하고, 추가하며, 조회하고 검색할 수 있는 기능</li>\n<li><strong>찜 목록</strong>: 사용자가 관심 있는 아이템을 폴더별로 관리하고, 찜 목록을 조회하며, 폴더를 생성, 수정, 이동하는 기능</li>\n<li><strong>투표 생성/추가/조회</strong>: 사용자가 투표를 생성하고, 추가하며, 조회할 수 있는 기능</li>\n<li><strong>마이페이지</strong>: 사용자 개인 정보 및 활동 내역을 관리하는 페이지</li>\n</ul>\n<h2>3. 역할</h2>\n<p>프론트엔드 개발:</p>\n<ol>\n<li>아이템 목록 페이지: 무한 스크롤 기능을 적용하여 사용자 경험을 개선</li>\n<li>찜 목록 및 상세 페이지: 폴더 생성/삭제, 폴더 이동, 폴더 이름 수정 등의 기능을 개발</li>\n<li>검색 기능: 사용자들이 원하는 취미 상품을 빠르게 찾을 수 있도록 구현</li>\n<li>레이아웃 및 반응형 UI: 다양한 디바이스에서 일관된 사용자 경험을 제공하기 위해 반응형 UI 가이드라인을 설계 및 개발</li>\n</ol>\n<h2>4. 기술 선택 이유</h2>\n<ul>\n<li>Next.js 13: 최신 기능과 성능 최적화를 위해 선택. 서버사이드 렌더링(SSR)을 통해 초기 로딩 속도를 개선</li>\n<li>React-Query: 데이터 패칭 및 캐싱을 효율적으로 처리하여 상태 관리의 복잡성을 줄이고, 개발 생산성을 높이기 위해 도입</li>\n<li>Tailwind CSS: 일관된 스타일링과 재사용 가능한 컴포넌트 작성을 위해 선택. 스타일링 작업의 생산성을 높이고 유지보수를 용이하게 함</li>\n</ul>\n<h2>5. 성능 최적화</h2>\n<ul>\n<li>무한 스크롤: 아이템 목록 페이지에 무한 스크롤을 적용하여 초기 로딩 시간을 줄이고, 사용자 경험을 개선</li>\n<li>서버사이드 렌더링: Next.js의 서버사이드 렌더링 기능을 활용하여 페이지 로딩 속도를 최적화</li>\n<li>React-Query: 데이터 패칭 및 캐싱을 통해 네트워크 요청 수를 줄이고, 응답 속도를 개선</li>\n</ul>\n<h2>6. 회고</h2>\n<p>LIME 프로젝트는 백엔드 3명, 프론트엔드 2명, 디자이너 1명으로 구성하여 진행한 팀 프로젝트입니다.</p>\n<p>주기적으로 한 시간 정도 온라인 회의를 통해 기획과 개발 진행 상황을 점검했고, <code>Notion</code>, <code>Slack</code>, <code>Jira</code> 등의 툴을 활용하여 커뮤니케이션을 진행했습니다.</p>\n<p>초반에는 경력자로서 토이 프로젝트가 이직 준비에 큰 도움이 될지에 대한 의문이 있었습니다. 그러나 새로운 기술들을 적극적으로 사용해보는 기회로 삼고, 팀원들과의 협업 과정을 통해 많은 것을 배울 수 있을 것이라는 확신이 들어 프로젝트에 참여하게 되었습니다.</p>\n<p>프론트엔드 개발자가 두 명뿐이었지만, 커밋 컨벤션과 브랜치 네이밍 규칙을 확실히 정하고 코드 리뷰 시스템을 도입하여 코드 품질을 높였습니다. 이전 회사에서는 코드 리뷰 시스템을 도입하는 것이 어려웠지만, 이번 프로젝트를 통해 코드 리뷰의 중요성을 체감할 수 있었습니다. 특히, <code>Next.js</code> 13버전과 <code>React-Query</code>를 실제로 사용해보면서 기술적 자신감을 얻었습니다.</p>\n<p>이번 프로젝트는 단순한 토이 프로젝트를 넘어, 새로운 기술을 사용해보고 팀원들과의 협업을 통해 실무 능력을 향상시킬 수 있는 소중한 경험이었습니다. 이 경험을 바탕으로 앞으로도 계속해서 성장할 수 있을 것이라는 확신을 가지게 되었습니다. 😇</p>"}},{"node":{"frontmatter":{"title":"sfoo"},"html":"<h2>1. 프로젝트 소개</h2>\n<p>대학 주변의 맛집을 추천해주는 사이트입니다. <br>\n사용자는 음식점을 검색하고 리뷰를 작성할 수 있으며, 학교 및 학과별 게시판을 통해 정보를 공유할 수 있습니다.</p>\n<h2>2. 기능 명세</h2>\n<ol>\n<li><strong>음식점 검색</strong> : 대학 주변의 음식점을 검색할 수 있습니다.</li>\n<li><strong>리뷰 작성</strong> : 음식점에 대한 리뷰를 작성할 수 있습니다.</li>\n<li><strong>게시판 기능</strong> : 학교 및 학과별로 게시판을 제공하여 학생들이 정보를 공유할 수 있습니다.</li>\n</ol>\n<h2>3. 역할</h2>\n<ol>\n<li>프로젝트 초기 세팅 - <a href=\"https://github.com/TeamDogeC-2/StudentSoup/pull/57\">PR #57</a>\n<ol>\n<li>prettier 및 eslint 적용</li>\n<li>Title 및 Favicon 적용</li>\n</ol>\n</li>\n<li>Github Repository 관리\n<ol>\n<li>branch rule, commit convention, pull request template 생성</li>\n</ol>\n</li>\n<li>Front-end 코드 관리\n<ol>\n<li>코드 리뷰 및 Github Merge 담당</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/assets/image/code-review_1.png\" alt=\"img\"></p>\n<ol start=\"4\">\n<li>페이지 라우팅 처리 - <a href=\"https://github.com/TeamDogeC-2/StudentSoup/pull/12\">PR #12</a></li>\n<li>회원가입 3번째 페이지 퍼블리싱 - <a href=\"https://github.com/TeamDogeC-2/StudentSoup/pull/20\">PR #20</a></li>\n<li>게시판 페이지 Front-end 개발 - <a href=\"https://github.com/TeamDogeC-2/StudentSoup/pull/137\">PR #137</a> <a href=\"https://github.com/TeamDogeC-2/StudentSoup/pull/184\">PR #184</a> <a href=\"https://github.com/TeamDogeC-2/StudentSoup/pull/225\">PR #225</a></li>\n</ol>\n<h2>4. 기술 선택 이유</h2>\n<ul>\n<li>TypeScript: 정적 타입 지정을 통해 코드의 가독성과 유지보수성을 향상시키고, 버그를 사전에 방지할 수 있도록 선택했습니다.</li>\n<li>React.js: 컴포넌트 기반 아키텍처를 활용하여 개발 생산성을 높이기 위해 선택했습니다.</li>\n<li>Tailwind CSS: 인라인 스타일링보다는 클래스 기반의 스타일 지정을 선호하는 저희 팀에게 적합한 CSS 프레임워크로, 커스터마이징이 용이하고 일관된 디자인을 유지하기 위해 선택했습니다.</li>\n<li>Recoil: React 애플리케이션에서 상태 관리를 효율적으로 할 수 있도록 하는 라이브러리로, 복잡한 상태 관리를 간단하게 처리할 수 있고, 컴포넌트 간 데이터 공유를 용이하게 하기 위해 선택했습니다.</li>\n</ul>\n<h2>5. 회고</h2>\n<p>백엔드 2명, 프론트엔드 4명, 디자이너 1명으로 팀을 구성하여 개발한 서비스입니다. 저를 제외한 팀원은 모두 학생 혹은 취업준비생이었기 때문에 저는 많은 기능을 개발하기보다는 프로젝트와 코드 관리에 집중하였습니다.</p>\n<p>프로젝트 생성부터 eslint, prettier 규칙을 추가하고, 폴더 구조와 브랜치 네이밍, 커밋 컨벤션, PR 템플릿 등을 고민하는 시간을 가질 수 있었고, 코드 리뷰어 역할을 맡아 더 확실한 정보를 제공하기 위해 관련 내용을 더 찾아보는 시간을 가지며 역량을 쌓을 수 있었습니다.</p>"}},{"node":{"frontmatter":{"title":"maplescouter"},"html":"<h2>1. 프로젝트 소개</h2>\n<p>메이플스토리 게임 내 캐릭터의 스펙을 객관적으로 제공하고, 효율을 계산해주는 사이트입니다.</p>\n<p>넥슨 오픈 API를 통해 사용자의 아이템을 보여주고, 보스 컷을 계산해주는 기능을 갖추고 있습니다. 현재 하루 약 <strong>3만 명</strong>이 이용 중인 서비스로, 보안상의 이유로 Repository는 Private로 관리되고 있습니다.</p>\n<h2>2. 기능 명세</h2>\n<ol>\n<li><strong>홈</strong> : 캐릭터를 검색하고 즐겨찾기한 캐릭터를 확인할 수 있는 페이지</li>\n<li><strong>직접 입력</strong> : 상세 스탯을 직접 기입하여 환산 결과를 출력하는 입력 폼 페이지</li>\n<li><strong>결과</strong> : 보스컷을 계산하여 출력해주는 페이지</li>\n<li><strong>캐릭터 정보</strong> : 넥슨 오픈 API를 통해 가져온 캐릭터 아이템을 상세히 보여주고, 환산 결과를 계산하여 출력하는 페이지</li>\n<li><strong>헥사/하이퍼 최적화</strong> : 헥사 스탯과 하이퍼 스탯의 최적화된 값을 계산해주는 페이지</li>\n<li><strong>헥사 코어 최적화</strong> : 헥사 코어의 최적화된 강화 순서를 보여주는 페이지</li>\n<li><strong>기록실</strong> : TOP100 랭킹을 보여주는 페이지</li>\n</ol>\n<h2>3. 역할</h2>\n<ul>\n<li>7개의 페이지에 대한 UI 디자인 및 퍼블리싱 작업</li>\n<li>UI/UX 개선 및 반응형 디자인 구현</li>\n<li>tailwind CSS로 전체 스타일링 변경</li>\n<li>API 로딩, 즐겨찾기, 프로필 이미지 저장 기능 등 추가</li>\n</ul>\n<h2>4. 기술 선택 이유</h2>\n<ul>\n<li>tailwind CSS: 기존 styled-component를 tailwind로 변경하여 코드의 일관성과 성능을 개선하고, 반응형 디자인을 더 효율적으로 구현하기 위해 선택</li>\n</ul>\n<h2>5. 성능 최적화</h2>\n<ul>\n<li>`styled-component에서 tailwind로 변경하여 CSS 로딩 시간을 단축하고, 페이지 렌더링 성능을 개선</li>\n<li>UI/UX 개선을 통해 사용자 경험을 향상시키고, 모바일 환경에서의 사용성을 개선</li>\n</ul>\n<h2>6. 회고</h2>\n<p>이 프로젝트는 처음에는 스프레드시트로 제작되어 대부분의 사용자가 이용하던 서비스였습니다. 하지만 관리가 점점 어려워지면서 웹 버전이 출시되었고, 사이트에 들어가 보니 어떤 것이 입력란인지, 버튼인지 구분하기 어렵고, 모바일 환경에서는 모달이 잘리는 등 UI/UX 개선이 필요해 보였습니다.</p>\n<p>연락할 수단을 찾아 UI/UX 개선을 도와주겠다는 의견을 적극적으로 전달했고, 긍정적인 반응을 얻어 프로젝트에 합류하게 되었습니다.</p>\n<p>디자이너가 따로 없었기 때문에 Figma를 통해 직접 디자인 작업을 진행했고, 퍼블리싱 작업을 통해 UI/UX를 개선했습니다. 그리고, 더 나은 성능과 빠른 로딩을 위해 <code>styled-component</code>로 구현된 컴포넌트를 모두 <code>tailwind</code>로 변경하는 작업도 진행했습니다.</p>\n<p>회사에서는 보통 디자인팀과 기획팀이 따로 있어 개발자는 Figma를 보고 개발만 하면 되었기 때문에 UX를 깊이 고민할 기회가 없었습니다. 하지만 이번 프로젝트를 진행하면서 실 사용자들의 피드백을 받아 사용자 관점에서 UX를 고민하는 시간을 많이 가졌고, 이는 프론트엔드 개발자로서 매우 가치 있는 경험이었습니다.</p>\n<p>보수 없이 진행되는 프로젝트였지만, 그 어느 때보다 열정을 가지고 개발했습니다. 빨리 사용자에게 보여주고 싶은 마음에 아침 7시까지 개발에 집중한 적도 있습니다. 이 프로젝트를 통해 많은 성취감을 느꼈습니다.</p>\n<h2>+ 참고 (개선 전 초기 디자인)</h2>\n<p><img src=\"/assets/image/input_before.png\" alt=\"img\">\n<img src=\"/assets/image/result_before.png\" alt=\"img\"></p>"}},{"node":{"frontmatter":{"title":"blog"},"html":"<h2>1. 프로젝트 개요</h2>\n<p><code>React</code> 기반 프레임워크인 <code>Gatsby.js</code>와 <code>GraphQL</code>을 사용하여 포트폴리오 사이트를 제작했습니다. <br>\n이 프로젝트에서의 주 목표는 새로운 기술을 활용하여 빠르고 사용자 경험이 뛰어난 블로그를 만드는 것이었습니다. <br>\n이를 위해 <code>Gatsby.js</code>의 <code>gatsby-starter-portfolio-minimal-theme</code> 테마를 사용하고, 필요에 맞게 커스텀하여 제작했습니다.</p>\n<p><code>Notion</code>, <code>Tistory</code>, <code>Velog</code> 등 포트폴리오로 사용할 수 있는 플랫폼이 많이 존재하지만, 프론트엔드 개발자라면 직접 만든 나만의 포트폴리오 사이트를 가지는 것이 좋겠다는 생각이 들어 이 블로그를 제작하게 되었습니다.</p>\n<h2>2. 기술 선택 이유</h2>\n<p><strong>Gatsby.js:</strong></p>\n<ol>\n<li>정적 사이트 생성 방식으로 SEO 최적화와 빠른 로딩 속도를 제공</li>\n<li>React 기반 프레임워크로, 익숙하고 효율적</li>\n<li>다양한 플러그인으로 기능을 쉽게 확장 가능</li>\n</ol>\n<p><strong>GraphQL:</strong></p>\n<ol>\n<li>요청 횟수와 응답 크기를 최소화</li>\n<li>데이터 구조와 쿼리를 명확히 정의하여 서버와 클라이언트 간의 통신을 최적화</li>\n</ol>\n<h2>3. 테마 적용 및 커스텀</h2>\n<ol>\n<li>\n<p>Gatsby CLI를 사용하여 프로젝트를 초기화하고 <code>gatsby-starter-portfolio-minimal-theme</code> 테마를 적용했습니다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">npx gatsby new my-blog https://github.com/PortfolioMinimal/gatsby-starter-portfolio-minimal-theme\ncd my-blog</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>기본 테마의 디자인과 레이아웃을 필요에 맞게 커스텀했습니다.</p>\n</li>\n</ol>\n<ul>\n<li>레이아웃 변경: 헤더와 푸터의 스타일을 변경하고, 포스트 목록의 레이아웃을 조정했습니다.</li>\n<li>스타일링: styled-components를 사용하여 CSS를 커스텀하고, 사이트의 전반적인 색상과 타이포그래피를 변경했습니다.</li>\n<li>새로운 페이지 추가: 프로젝트와 블로그 포스트 외에도 새로운 섹션을 추가하여 포트폴리오를 확장했습니다.</li>\n</ul>\n<ol start=\"3\">\n<li>데이터 소스 설정</li>\n</ol>\n<ul>\n<li>Markdown 파일을 이용하여 블로그 포스트 데이터를 관리했습니다. gatsby-source-filesystem 플러그인을 통해 파일 시스템에서 데이터를 가져오고, gatsby-transformer-remark 플러그인을 사용하여 Markdown 파일을 파싱했습니다.</li>\n</ul>\n<ol start=\"4\">\n<li>GraphQL 설정</li>\n</ol>\n<ul>\n<li>\n<p>GraphQL 스키마를 설정하고 필요한 쿼리를 작성했습니다. Gatsby의 GraphQL 인터페이스를 사용하면 매우 직관적이고 쉬운 쿼리 작성이 가능했습니다.</p>\n<deckgo-highlight-code language=\"graphql\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">query BlogPostBySlug($slug: String!) {\n  markdownRemark(fields: { slug: { eq: $slug } }) {\n    frontmatter {\n      title\n      date(formatString: &quot;MMMM DD, YYYY&quot;)\n    }\n    html\n  }\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<ol start=\"5\">\n<li>페이지 생성</li>\n</ol>\n<ul>\n<li>\n<p>Gatsby의 Node API 중 createPages를 사용하여 동적으로 페이지를 생성했습니다. 각 블로그 포스트마다 고유한 URL을 생성하고, 해당 페이지에 데이터를 주입했습니다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">exports.createPages = ({ graphql, actions }) =&gt; {\n  const { createPage } = actions;\n  const blogPostTemplate = path.resolve(`src/templates/blog-post.js`);\n\n  return graphql(`\n    {\n      allMarkdownRemark {\n        edges {\n          node {\n            fields {\n              slug\n            }\n          }\n        }\n      }\n    }\n  `).then((result) =&gt; {\n    result.data.allMarkdownRemark.edges.forEach(({ node }) =&gt; {\n      createPage({\n        path: node.fields.slug,\n        component: blogPostTemplate,\n        context: {\n          slug: node.fields.slug,\n        },\n      });\n    });\n  });\n};</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>4. 성능 최적화</h2>\n<p>Gatsby.js는 기본적으로 성능 최적화에 중점을 두고 있지만, 추가적으로 몇 가지 작업을 통해 성능을 더욱 개선했습니다.</p>\n<ol>\n<li>이미지 최적화: gatsby-image와 gatsby-plugin-sharp를 사용하여 이미지의 크기를 최적화하고, 필요에 따라 로드되도록 설정</li>\n<li>코드 스플리팅: 필요한 시점에 필요한 코드만 로드하도록 설정하여 초기 로딩 속도를 개선</li>\n<li>프리패칭: Link 컴포넌트를 사용하여 사용자가 링크를 클릭하기 전에 리소스를 미리 로드</li>\n</ol>\n<h2>5. 문제 해결</h2>\n<ol>\n<li>\n<p>Markdown 파싱 이슈: SSG 방식에 익숙하지 않아 useEffect로 Markdown 데이터를 가져오면서 404 페이지가 노출되는 문제가 발생하였습니다. Markdown 데이터를 사용하는 페이지를 모두 SSG 방식으로 렌더링되도록 변경하여 문제를 해결했습니다.</p>\n<ul>\n<li><a href=\"https://velog.io/@yr1m/Gatsby.js-Trouble-Shooting-SSG-SSR-DSG\">[Gatsby.js] Trouble Shooting : SSG, SSR, DSG</a></li>\n</ul>\n</li>\n<li>\n<p>쿼리 에러: page-data를 찾지 못하는 문제가 발생하였습니다. graphiQL 도구를 이용하여 쿼리를 만들면서 동일한 쿼리 이름으로 인해 발생한 에러인 것을 확인하고, 쿼리 이름을 변경하여 해결했습니다.</p>\n<ul>\n<li><a href=\"https://velog.io/@yr1m/Gatsby.js-Trouble-Shooting-ModuleNotFoundError\">[Gatsby.js] Trouble Shooting : ModuleNotFoundError ...page-data</a></li>\n</ul>\n</li>\n</ol>\n<h2>6. RestAPI와 GraphQL 비교</h2>\n<p>GraphQL로 블로그 프로젝트를 진행하면서 이전에 사용해 본 RestAPI와 특징을 비교해 보았습니다.</p>\n<p><strong>RestAPI:</strong></p>\n<ol>\n<li>명확한 엔드포인트: 각 리소스에 대해 고유한 URL을 가지고 있어 엔드포인트가 명확합니다.</li>\n<li>간단한 사용법: HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 CRUD 작업을 쉽게 수행할 수 있습니다.</li>\n<li>캐싱: HTTP 캐싱을 통해 성능을 최적화할 수 있습니다.</li>\n</ol>\n<p><strong>GraphQL:</strong></p>\n<ol>\n<li>유연한 데이터 쿼리: 단일 엔드포인트에서 필요한 데이터를 한 번의 요청으로 정확하게 가져올 수 있습니다.</li>\n<li>과잉/과소 데이터 문제 해결: 클라이언트가 필요한 필드만 요청할 수 있어 불필요한 데이터 전송을 줄입니다.</li>\n<li>버전 관리 불필요: 스키마를 통해 데이터 구조를 정의하므로 API 버전 관리를 할 필요가 없습니다.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">특성</th>\n<th align=\"center\">RestAPI</th>\n<th align=\"center\">GraphQL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">엔드포인트 관리</td>\n<td align=\"center\">여러 엔드포인트 필요</td>\n<td align=\"center\">단일 엔드포인트</td>\n</tr>\n<tr>\n<td align=\"center\">데이터 fetch</td>\n<td align=\"center\">다중 요청 필요 가능</td>\n<td align=\"center\">한 번의 요청으로 필요한 데이터 모두 페칭</td>\n</tr>\n<tr>\n<td align=\"center\">효율성</td>\n<td align=\"center\">과잉 또는 과소 데이터 문제 발생 가능</td>\n<td align=\"center\">필요한 데이터만 정확히 요청</td>\n</tr>\n<tr>\n<td align=\"center\">버전 관리</td>\n<td align=\"center\">새로운 버전의 API 필요</td>\n<td align=\"center\">스키마로 버전 관리 불필요</td>\n</tr>\n<tr>\n<td align=\"center\">캐싱</td>\n<td align=\"center\">HTTP 캐싱 사용 가능</td>\n<td align=\"center\">캐싱 직접 구현 필요</td>\n</tr>\n<tr>\n<td align=\"center\">복잡성</td>\n<td align=\"center\">비교적 단순, 명확</td>\n<td align=\"center\">초기 설정 및 학습 곡선 존재</td>\n</tr>\n</tbody>\n</table>\n<p>GraphQL을 사용하면서 느낀 가장 큰 장점은 필요한 데이터를 정확히 쿼리할 수 있다는 점과 단일 엔드포인트로 모든 요청을 처리할 수 있다는 점이었습니다. 이는 특히 복잡한 데이터 구조를 가진 애플리케이션에서 매우 유용했습니다. 반면, RestAPI는 간단하고 명확한 구조로 인해 초기 설정이 더 쉽고, 기존의 캐싱 메커니즘을 그대로 활용할 수 있다는 장점이 있었습니다.</p>\n<h2>7. 회고</h2>\n<p>이번 프로젝트를 통해 <code>Gatsby.js</code>와 <code>GraphQL</code> 기술을 활용하는 방법과 정적 사이트 생성의 장점을 깊이 이해할 수 있었습니다. gatsby-starter-portfolio-minimal-theme 테마를 활용하고 커스텀함으로써 성능이 뛰어나고 유지보수가 용이한 블로그를 만들 수 있었으며, 앞으로 더 많은 기능을 추가하고 개선해 나갈 계획입니다. 특히, 데이터 소스를 유연하게 관리하고 최적화하는 방법을 익힌 것이 큰 성과였습니다.</p>\n<h2>8. 향후 계획</h2>\n<ol>\n<li>페이지 추가: 공부한 내용을 정리하고, 고민 거리에 대해 포스팅을 작성하는 Markdown 기반 페이지 추가</li>\n<li>UI/UX 개선: 사용자 경험을 향상시키기 위한 디자인 및 인터렉션 개선</li>\n<li>자동화: 배포 파이프라인 자동화 및 테스트 코드 작성</li>\n</ol>\n<p>이번 프로젝트는 Gatsby.js와 GraphQL을 활용한 첫 경험이었지만, 앞으로도 이 기술들을 적극 활용하여 다양한 웹 프로젝트에 적용해볼 계획입니다.</p>"}}]}}}